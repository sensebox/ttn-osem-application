<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/ttn.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/ttn.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

/**
 * Handles communication with the TTN backend, providing functions for
 * retrieval &amp; registration of devices for a TTN application, and sets up a
 * MQTT connection, to decode all received uplink messages as measurements.
 * This assumes that each device in the application maps to a box, where
 * `dev_id === box._id`.
 * @module ttn
 * @license MIT
 */

const { data, application, key } = require('ttn');

const cfg = require('../config');
const { boxFromBoxId } = require('./database');
const { TTNError } = require('./errors');
const decoder = require('./decoding');
const { createLogger } = require('./logging');

const log = createLogger('ttn');

/**
 * Handler for MQTT uplink messages
 * @private
 * @param {string} dev_id - the ID of the sending device
 * @param {Object} message - payload object as described {@link https://www.thethingsnetwork.org/docs/applications/mqtt/api.html|here}
 */
const onUplinkMessage = function onUplinkMessage (dev_id, message) {
  let matchBox;

  // match associated box via dev_id === box._id
  boxFromBoxId(dev_id, { lean: false })
    // decode measurements from request.body, req.box &amp; req.time
    .then(box => {
      log.debug({ box }, `matched box for dev_id ${dev_id}`);
      matchBox = box;

      return decoder.decodeRequest(message, box);
    })
    // store result in DB
    .then(measurements => {
      log.debug({ measurements }, 'resulting measurements');

      return matchBox.saveMeasurementsArray(measurements);
    })
    .then(() => log.info(`saved measurements for ${dev_id}`))
    .catch(err => {
      if (err instanceof TTNError) {
        log.warn({ err }, 'could not handle uplink message');
      } else {
        log.error({ err });
      }
    });
};

/**
 * Connects to the TTN MQTT broker and subscribes to incoming messages.
 * @private
 * @return {Promise}
 */
const initMqtt = function initMqtt () {
  mqttClient = data(cfg.ttn.appId, cfg.ttn.key)
    .then(client => {
      client.on('error', function onTTNError (err) {
        log.error({ err }, 'could not connect to TTN');
      });

      client.on('connect', function onTTNConnection () {
        log.info(`connected to TTN app ${cfg.ttn.appId}`);
      });

      client.on('uplink', onUplinkMessage);

      return client;
    });

  return mqttClient;
};

/**
 * Resolves the application at any TTN handler.
 * @private
 * @return {Promise}
 */
const initApp = function initApp () {
  const { appId, key } = cfg.ttn;
  appClient = application(appId, key)
    .then(client => {
      // to register devices, we need the apps EUI,
      // which we fetch once from the account server
      return client.getEUIs()
        .then(euis => {
          log.info({ euis }, `resolved TTN app ${appId}`);
          client.appEui = euis[0];

          return client;
        });
    });

  return appClient;
};

// getters that return a Promise for the clients but initialize them only once
let mqttClient, appClient;

/**
 * Initializes and returns a client for the TTN ApplicationManager API for the
 * configured app_id
 * @returns {Promise}
 */
const getApp = () => appClient || initApp();

/**
 * Initializes and returns a client for the TTN MQTT Broker for the
 * configured app_id. Enables the subscription to uplink messages on the
 * configured application.
 * @returns {Promise}
 */
const getMqtt = () => mqttClient || initMqtt();

/**
 * Returns a TTN device registered at cfg.ttn.appId. If it does not exist,
 * a new device is created with randomized keys and boxId === dev_id.
 * IDEA: maintain local device cache, and check it first?
 * @param {string} boxId
 * @param {string} [dev_eui] - The EUI of the device if known
 * @return {Promise} resolves with the device data
 */
const getOrRegisterDevice = function getOrRegisterDevice (boxId, dev_eui) {

  let app;

  return getApp()
    .then(ttnApp => {
      app = ttnApp;

      return app.device(boxId);
    })
    // the device likely wasn't found, let's create it
    .catch(err => {
      if (err.message !== `handler:device:${cfg.ttn.appId}:${boxId} not found`) {
        throw new Error(`could not find a device for box ${boxId}: ${err.message}`);
      }

      log.info(`box ${boxId} has no TTN device, registering a new one`);

      // as the enduser has no control over this, we
      // apply settings that work for most situations
      const deviceOpts = {
        // devEui is normally assigned to hardware by lora chip vendor.
        // if that value is unknown, we generate a pseudo unique ID.
        // user generated euis must be prefixed with 0x00.
        devEui: dev_eui || `00${key(7)}`,
        appEui: app.appEui,
        disableFCntCheck: true,

        appKey: key(16), // OTAA key

        // ABP keys. OTAA should be used, but we assign keys just in case
        nwkSKey: key(16),
        appSKey: key(16),
        // normally uniquely choosen by network server with prefix 0x2601
        devAddr: `2601${key(2)}`,
      };

      return app.registerDevice(boxId, deviceOpts)
        // still need to fetch the device data
        .then(() => app.device(boxId));
    });
};

module.exports = {
  getMqtt,
  getApp,
  getOrRegisterDevice,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-database.html">database</a></li><li><a href="module-decoding.html">decoding</a></li><li><a href="module-decoding_debug.html">decoding/debug</a></li><li><a href="module-decoding_helpers.html">decoding/helpers</a></li><li><a href="module-decoding_lora-serialization.html">decoding/lora-serialization</a></li><li><a href="module-decoding_sensebox_home.html">decoding/sensebox_home</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-logging.html">logging</a></li><li><a href="module-routes_v1_1.html">routes/v1_1</a></li><li><a href="module-ttn.html">ttn</a></li></ul><h3>Classes</h3><ul><li><a href="module-errors-AuthorizationError.html">AuthorizationError</a></li><li><a href="module-errors-BoxNotFoundError.html">BoxNotFoundError</a></li><li><a href="module-errors-DecodingError.html">DecodingError</a></li><li><a href="module-errors-LoraError.html">LoraError</a></li><li><a href="module-errors-PayloadError.html">PayloadError</a></li><li><a href="module-errors-TTNError.html">TTNError</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Dec 06 2017 15:19:29 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
